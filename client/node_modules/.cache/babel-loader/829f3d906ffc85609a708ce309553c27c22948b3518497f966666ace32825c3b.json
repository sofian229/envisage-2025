{"ast":null,"code":"import webSocketService from './websocket';\nclass LocationService {\n  constructor() {\n    this.watchId = null;\n    this.isTracking = false;\n    this.listeners = {\n      update: [],\n      error: []\n    };\n    this.options = {\n      enableHighAccuracy: true,\n      maximumAge: 5000,\n      // Increased to reduce frequency of updates\n      timeout: 10000\n    };\n    this.lastPosition = null;\n    this.minUpdateInterval = 2000; // Minimum time between updates in ms\n    this.lastUpdateTime = 0;\n    this.errorCount = 0;\n    this.maxErrorCount = 3;\n  }\n  startTracking() {\n    if (!navigator.geolocation) {\n      this.notifyListeners('error', new Error('Geolocation is not supported by your browser'));\n      return false;\n    }\n    if (this.isTracking) {\n      return true;\n    }\n    try {\n      // Reset error count\n      this.errorCount = 0;\n      this.watchId = navigator.geolocation.watchPosition(this.handlePositionUpdate.bind(this), this.handlePositionError.bind(this), this.options);\n      this.isTracking = true;\n      return true;\n    } catch (error) {\n      this.notifyListeners('error', error);\n      return false;\n    }\n  }\n  stopTracking() {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n      this.isTracking = false;\n    }\n  }\n  handlePositionUpdate(position) {\n    const now = Date.now();\n\n    // Throttle updates to prevent too frequent position changes\n    if (now - this.lastUpdateTime < this.minUpdateInterval) {\n      return;\n    }\n\n    // Check if position has changed significantly\n    if (this.lastPosition) {\n      const prevLat = this.lastPosition.coords.latitude;\n      const prevLng = this.lastPosition.coords.longitude;\n      const newLat = position.coords.latitude;\n      const newLng = position.coords.longitude;\n\n      // Calculate distance (very rough approximation)\n      const distance = Math.sqrt(Math.pow(newLat - prevLat, 2) + Math.pow(newLng - prevLng, 2));\n\n      // If position hasn't changed much, don't update\n      if (distance < 0.00001) {\n        // Very small threshold\n        return;\n      }\n    }\n    this.lastPosition = position;\n    this.lastUpdateTime = now;\n    const coordinates = {\n      latitude: position.coords.latitude,\n      longitude: position.coords.longitude,\n      accuracy: position.coords.accuracy,\n      timestamp: position.timestamp\n    };\n\n    // Reset error count on successful update\n    this.errorCount = 0;\n\n    // Notify local listeners\n    this.notifyListeners('update', coordinates);\n\n    // Send to server via WebSocket\n    webSocketService.sendMessage({\n      type: 'locationUpdate',\n      coordinates\n    });\n  }\n  handlePositionError(error) {\n    this.errorCount++;\n\n    // If we've had too many errors, stop tracking\n    if (this.errorCount >= this.maxErrorCount) {\n      this.stopTracking();\n    }\n    let errorMessage;\n    switch (error.code) {\n      case error.PERMISSION_DENIED:\n        errorMessage = 'Location access denied. Please enable location services.';\n        break;\n      case error.POSITION_UNAVAILABLE:\n        errorMessage = 'Location information is unavailable.';\n        break;\n      case error.TIMEOUT:\n        errorMessage = 'Location request timed out.';\n        break;\n      default:\n        errorMessage = 'An unknown error occurred while getting location.';\n    }\n    const errorObj = new Error(errorMessage);\n    errorObj.originalError = error;\n    this.notifyListeners('error', errorObj);\n  }\n  addListener(event, callback) {\n    if (this.listeners[event]) {\n      this.listeners[event].push(callback);\n    }\n  }\n  removeListener(event, callback) {\n    if (this.listeners[event]) {\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n    }\n  }\n  removeAllListeners() {\n    this.listeners = {\n      update: [],\n      error: []\n    };\n  }\n  notifyListeners(event, data) {\n    if (this.listeners[event]) {\n      this.listeners[event].forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in ${event} listener:`, error);\n        }\n      });\n    }\n  }\n}\nconst locationService = new LocationService();\nexport default locationService;","map":{"version":3,"names":["webSocketService","LocationService","constructor","watchId","isTracking","listeners","update","error","options","enableHighAccuracy","maximumAge","timeout","lastPosition","minUpdateInterval","lastUpdateTime","errorCount","maxErrorCount","startTracking","navigator","geolocation","notifyListeners","Error","watchPosition","handlePositionUpdate","bind","handlePositionError","stopTracking","clearWatch","position","now","Date","prevLat","coords","latitude","prevLng","longitude","newLat","newLng","distance","Math","sqrt","pow","coordinates","accuracy","timestamp","sendMessage","type","errorMessage","code","PERMISSION_DENIED","POSITION_UNAVAILABLE","TIMEOUT","errorObj","originalError","addListener","event","callback","push","removeListener","filter","cb","removeAllListeners","data","forEach","console","locationService"],"sources":["C:/Programming/Clubs/CIS/HackPrix/drift-guard-1pm/client/src/utils/locationService.js"],"sourcesContent":["import webSocketService from './websocket';\n\nclass LocationService {\n  constructor() {\n    this.watchId = null;\n    this.isTracking = false;\n    this.listeners = {\n      update: [],\n      error: []\n    };\n    this.options = {\n      enableHighAccuracy: true,\n      maximumAge: 5000, // Increased to reduce frequency of updates\n      timeout: 10000\n    };\n    this.lastPosition = null;\n    this.minUpdateInterval = 2000; // Minimum time between updates in ms\n    this.lastUpdateTime = 0;\n    this.errorCount = 0;\n    this.maxErrorCount = 3;\n  }\n\n  startTracking() {\n    if (!navigator.geolocation) {\n      this.notifyListeners('error', new Error('Geolocation is not supported by your browser'));\n      return false;\n    }\n    \n    if (this.isTracking) {\n      return true;\n    }\n    \n    try {\n      // Reset error count\n      this.errorCount = 0;\n      \n      this.watchId = navigator.geolocation.watchPosition(\n        this.handlePositionUpdate.bind(this),\n        this.handlePositionError.bind(this),\n        this.options\n      );\n      \n      this.isTracking = true;\n      return true;\n    } catch (error) {\n      this.notifyListeners('error', error);\n      return false;\n    }\n  }\n\n  stopTracking() {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n      this.isTracking = false;\n    }\n  }\n\n  handlePositionUpdate(position) {\n    const now = Date.now();\n    \n    // Throttle updates to prevent too frequent position changes\n    if (now - this.lastUpdateTime < this.minUpdateInterval) {\n      return;\n    }\n    \n    // Check if position has changed significantly\n    if (this.lastPosition) {\n      const prevLat = this.lastPosition.coords.latitude;\n      const prevLng = this.lastPosition.coords.longitude;\n      const newLat = position.coords.latitude;\n      const newLng = position.coords.longitude;\n      \n      // Calculate distance (very rough approximation)\n      const distance = Math.sqrt(\n        Math.pow(newLat - prevLat, 2) + \n        Math.pow(newLng - prevLng, 2)\n      );\n      \n      // If position hasn't changed much, don't update\n      if (distance < 0.00001) { // Very small threshold\n        return;\n      }\n    }\n    \n    this.lastPosition = position;\n    this.lastUpdateTime = now;\n    \n    const coordinates = {\n      latitude: position.coords.latitude,\n      longitude: position.coords.longitude,\n      accuracy: position.coords.accuracy,\n      timestamp: position.timestamp\n    };\n    \n    // Reset error count on successful update\n    this.errorCount = 0;\n    \n    // Notify local listeners\n    this.notifyListeners('update', coordinates);\n    \n    // Send to server via WebSocket\n    webSocketService.sendMessage({\n      type: 'locationUpdate',\n      coordinates\n    });\n  }\n\n  handlePositionError(error) {\n    this.errorCount++;\n    \n    // If we've had too many errors, stop tracking\n    if (this.errorCount >= this.maxErrorCount) {\n      this.stopTracking();\n    }\n    \n    let errorMessage;\n    \n    switch (error.code) {\n      case error.PERMISSION_DENIED:\n        errorMessage = 'Location access denied. Please enable location services.';\n        break;\n      case error.POSITION_UNAVAILABLE:\n        errorMessage = 'Location information is unavailable.';\n        break;\n      case error.TIMEOUT:\n        errorMessage = 'Location request timed out.';\n        break;\n      default:\n        errorMessage = 'An unknown error occurred while getting location.';\n    }\n    \n    const errorObj = new Error(errorMessage);\n    errorObj.originalError = error;\n    \n    this.notifyListeners('error', errorObj);\n  }\n\n  addListener(event, callback) {\n    if (this.listeners[event]) {\n      this.listeners[event].push(callback);\n    }\n  }\n\n  removeListener(event, callback) {\n    if (this.listeners[event]) {\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n    }\n  }\n  \n  removeAllListeners() {\n    this.listeners = {\n      update: [],\n      error: []\n    };\n  }\n\n  notifyListeners(event, data) {\n    if (this.listeners[event]) {\n      this.listeners[event].forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in ${event} listener:`, error);\n        }\n      });\n    }\n  }\n}\n\nconst locationService = new LocationService();\nexport default locationService;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}