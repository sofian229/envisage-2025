{"ast":null,"code":"var _jsxFileName = \"C:\\\\Programming\\\\Clubs\\\\CIS\\\\HackPrix\\\\drift-guard-1pm\\\\client\\\\src\\\\contexts\\\\LocationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useRef } from 'react';\nimport { useAuth } from './AuthContext';\nimport webSocketService from '../utils/websocket';\nimport locationService from '../utils/locationService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LocationContext = /*#__PURE__*/createContext();\nexport const useLocation = () => {\n  _s();\n  return useContext(LocationContext);\n};\n_s(useLocation, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const LocationProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [myLocation, setMyLocation] = useState(null);\n  const [connectedUsers, setConnectedUsers] = useState({});\n  const [isTracking, setIsTracking] = useState(false);\n  const [trackingError, setTrackingError] = useState(null);\n  const [wsConnected, setWsConnected] = useState(false);\n\n  // Add refs to track state changes and prevent rapid toggling\n  const trackingTimeoutRef = useRef(null);\n  const isTrackingRef = useRef(false);\n  const trackingAttemptsRef = useRef(0);\n  const MAX_TRACKING_ATTEMPTS = 3;\n\n  // Initialize WebSocket connection when user is authenticated\n  useEffect(() => {\n    if (!user) return;\n    const token = localStorage.getItem('userToken');\n    if (!token) return;\n\n    // Connect to WebSocket\n    webSocketService.connect(token);\n\n    // Add WebSocket message listener\n    const handleMessage = data => {\n      if (data.type === 'locationUpdate' && data.userId !== user.id) {\n        setConnectedUsers(prev => ({\n          ...prev,\n          [data.userId]: {\n            userId: data.userId,\n            userName: data.userName,\n            role: data.role,\n            coordinates: data.coordinates,\n            timestamp: data.timestamp\n          }\n        }));\n      } else if (data.type === 'connected') {\n        setWsConnected(true);\n      }\n    };\n    const handleOpen = () => {\n      setWsConnected(true);\n    };\n    const handleClose = () => {\n      setWsConnected(false);\n    };\n    const handleError = () => {\n      setWsConnected(false);\n    };\n    webSocketService.addListener('message', handleMessage);\n    webSocketService.addListener('open', handleOpen);\n    webSocketService.addListener('close', handleClose);\n    webSocketService.addListener('error', handleError);\n\n    // Cleanup\n    return () => {\n      webSocketService.removeListener('message', handleMessage);\n      webSocketService.removeListener('open', handleOpen);\n      webSocketService.removeListener('close', handleClose);\n      webSocketService.removeListener('error', handleError);\n      webSocketService.disconnect();\n\n      // Clear any pending timeouts\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n        trackingTimeoutRef.current = null;\n      }\n    };\n  }, [user]);\n\n  // Start location tracking with debounce and error handling\n  const startLocationTracking = () => {\n    // Prevent starting if already tracking or if we've had too many attempts\n    if (isTrackingRef.current) {\n      return true;\n    }\n    if (trackingAttemptsRef.current >= MAX_TRACKING_ATTEMPTS) {\n      setTrackingError('Too many tracking attempts. Please refresh the page and try again.');\n      return false;\n    }\n\n    // Increment tracking attempts\n    trackingAttemptsRef.current += 1;\n    if (!user) {\n      setTrackingError('User must be logged in to track location');\n      return false;\n    }\n    setTrackingError(null);\n\n    // Set tracking state to prevent multiple calls\n    isTrackingRef.current = true;\n    setIsTracking(true);\n\n    // Add location update listener\n    const handleLocationUpdate = coordinates => {\n      setMyLocation({\n        coordinates\n      });\n\n      // Reset tracking attempts on successful update\n      trackingAttemptsRef.current = 0;\n    };\n    console.log(\"Updated myLocation state:\", {\n      coordinates\n    });\n    const handleLocationError = error => {\n      console.error('Location tracking error:', error);\n      setTrackingError(error.message || 'Unknown location tracking error');\n\n      // Use timeout to prevent rapid toggling\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n      }\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000); // 2 second delay before allowing state change\n    };\n    locationService.addListener('update', handleLocationUpdate);\n    locationService.addListener('error', handleLocationError);\n\n    // Start tracking with a delay to prevent rapid toggling\n    try {\n      const success = locationService.startTracking();\n      if (!success) {\n        // If tracking fails, set state after a delay\n        trackingTimeoutRef.current = setTimeout(() => {\n          setIsTracking(false);\n          isTrackingRef.current = false;\n          trackingTimeoutRef.current = null;\n        }, 2000);\n      }\n      return success;\n    } catch (error) {\n      console.error('Error starting location tracking:', error);\n\n      // Set state after a delay\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000);\n      return false;\n    }\n  };\n\n  // Stop location tracking with debounce\n  const stopLocationTracking = () => {\n    // Prevent stopping if not tracking\n    if (!isTrackingRef.current) {\n      return;\n    }\n\n    // Remove listeners first to prevent callbacks\n    locationService.removeAllListeners();\n    locationService.stopTracking();\n\n    // Set state with a slight delay to prevent rapid toggling\n    if (trackingTimeoutRef.current) {\n      clearTimeout(trackingTimeoutRef.current);\n    }\n    trackingTimeoutRef.current = setTimeout(() => {\n      setIsTracking(false);\n      isTrackingRef.current = false;\n      trackingTimeoutRef.current = null;\n    }, 500); // Half-second delay\n  };\n  return /*#__PURE__*/_jsxDEV(LocationContext.Provider, {\n    value: {\n      myLocation,\n      connectedUsers,\n      isTracking,\n      trackingError,\n      wsConnected,\n      startLocationTracking,\n      stopLocationTracking\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 193,\n    columnNumber: 5\n  }, this);\n};\n_s2(LocationProvider, \"D70RUUlfPdNxWMl0yz/ev4ec52k=\", false, function () {\n  return [useAuth];\n});\n_c = LocationProvider;\nvar _c;\n$RefreshReg$(_c, \"LocationProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useRef","useAuth","webSocketService","locationService","jsxDEV","_jsxDEV","LocationContext","useLocation","_s","LocationProvider","children","_s2","user","myLocation","setMyLocation","connectedUsers","setConnectedUsers","isTracking","setIsTracking","trackingError","setTrackingError","wsConnected","setWsConnected","trackingTimeoutRef","isTrackingRef","trackingAttemptsRef","MAX_TRACKING_ATTEMPTS","token","localStorage","getItem","connect","handleMessage","data","type","userId","id","prev","userName","role","coordinates","timestamp","handleOpen","handleClose","handleError","addListener","removeListener","disconnect","current","clearTimeout","startLocationTracking","handleLocationUpdate","console","log","handleLocationError","error","message","setTimeout","success","startTracking","stopLocationTracking","removeAllListeners","stopTracking","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Programming/Clubs/CIS/HackPrix/drift-guard-1pm/client/src/contexts/LocationContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useRef } from 'react';\r\nimport { useAuth } from './AuthContext';\r\nimport webSocketService from '../utils/websocket';\r\nimport locationService from '../utils/locationService';\r\n\r\nconst LocationContext = createContext();\r\n\r\nexport const useLocation = () => useContext(LocationContext);\r\n\r\nexport const LocationProvider = ({ children }) => {\r\n  const { user } = useAuth();\r\n  const [myLocation, setMyLocation] = useState(null);\r\n  const [connectedUsers, setConnectedUsers] = useState({});\r\n  const [isTracking, setIsTracking] = useState(false);\r\n  const [trackingError, setTrackingError] = useState(null);\r\n  const [wsConnected, setWsConnected] = useState(false);\r\n  \r\n  // Add refs to track state changes and prevent rapid toggling\r\n  const trackingTimeoutRef = useRef(null);\r\n  const isTrackingRef = useRef(false);\r\n  const trackingAttemptsRef = useRef(0);\r\n  const MAX_TRACKING_ATTEMPTS = 3;\r\n\r\n  // Initialize WebSocket connection when user is authenticated\r\n  useEffect(() => {\r\n    if (!user) return;\r\n\r\n    const token = localStorage.getItem('userToken');\r\n    if (!token) return;\r\n\r\n    // Connect to WebSocket\r\n    webSocketService.connect(token);\r\n\r\n    // Add WebSocket message listener\r\n    const handleMessage = (data) => {\r\n      if (data.type === 'locationUpdate' && data.userId !== user.id) {\r\n        setConnectedUsers(prev => ({\r\n          ...prev,\r\n          [data.userId]: {\r\n            userId: data.userId,\r\n            userName: data.userName,\r\n            role: data.role,\r\n            coordinates: data.coordinates,\r\n            timestamp: data.timestamp\r\n          }\r\n        }));\r\n      } else if (data.type === 'connected') {\r\n        setWsConnected(true);\r\n      }\r\n    };\r\n\r\n    const handleOpen = () => {\r\n      setWsConnected(true);\r\n    };\r\n\r\n    const handleClose = () => {\r\n      setWsConnected(false);\r\n    };\r\n\r\n    const handleError = () => {\r\n      setWsConnected(false);\r\n    };\r\n\r\n    webSocketService.addListener('message', handleMessage);\r\n    webSocketService.addListener('open', handleOpen);\r\n    webSocketService.addListener('close', handleClose);\r\n    webSocketService.addListener('error', handleError);\r\n\r\n    // Cleanup\r\n    return () => {\r\n      webSocketService.removeListener('message', handleMessage);\r\n      webSocketService.removeListener('open', handleOpen);\r\n      webSocketService.removeListener('close', handleClose);\r\n      webSocketService.removeListener('error', handleError);\r\n      webSocketService.disconnect();\r\n      \r\n      // Clear any pending timeouts\r\n      if (trackingTimeoutRef.current) {\r\n        clearTimeout(trackingTimeoutRef.current);\r\n        trackingTimeoutRef.current = null;\r\n      }\r\n    };\r\n  }, [user]);\r\n\r\n  // Start location tracking with debounce and error handling\r\n  const startLocationTracking = () => {\r\n    // Prevent starting if already tracking or if we've had too many attempts\r\n    if (isTrackingRef.current) {\r\n      return true;\r\n    }\r\n    \r\n    if (trackingAttemptsRef.current >= MAX_TRACKING_ATTEMPTS) {\r\n      setTrackingError('Too many tracking attempts. Please refresh the page and try again.');\r\n      return false;\r\n    }\r\n    \r\n    // Increment tracking attempts\r\n    trackingAttemptsRef.current += 1;\r\n    \r\n    if (!user) {\r\n      setTrackingError('User must be logged in to track location');\r\n      return false;\r\n    }\r\n\r\n    setTrackingError(null);\r\n    \r\n    // Set tracking state to prevent multiple calls\r\n    isTrackingRef.current = true;\r\n    setIsTracking(true);\r\n\r\n    // Add location update listener\r\n    const handleLocationUpdate = (coordinates) => {\r\n      setMyLocation({coordinates});\r\n      \r\n      // Reset tracking attempts on successful update\r\n      trackingAttemptsRef.current = 0;\r\n    };\r\n\r\n    console.log(\"Updated myLocation state:\", {coordinates});\r\n\r\n\r\n    const handleLocationError = (error) => {\r\n      console.error('Location tracking error:', error);\r\n      setTrackingError(error.message || 'Unknown location tracking error');\r\n      \r\n      // Use timeout to prevent rapid toggling\r\n      if (trackingTimeoutRef.current) {\r\n        clearTimeout(trackingTimeoutRef.current);\r\n      }\r\n      \r\n      trackingTimeoutRef.current = setTimeout(() => {\r\n        setIsTracking(false);\r\n        isTrackingRef.current = false;\r\n        trackingTimeoutRef.current = null;\r\n      }, 2000); // 2 second delay before allowing state change\r\n    };\r\n\r\n    locationService.addListener('update', handleLocationUpdate);\r\n    locationService.addListener('error', handleLocationError);\r\n\r\n    // Start tracking with a delay to prevent rapid toggling\r\n    try {\r\n      const success = locationService.startTracking();\r\n      \r\n      if (!success) {\r\n        // If tracking fails, set state after a delay\r\n        trackingTimeoutRef.current = setTimeout(() => {\r\n          setIsTracking(false);\r\n          isTrackingRef.current = false;\r\n          trackingTimeoutRef.current = null;\r\n        }, 2000);\r\n      }\r\n      \r\n      return success;\r\n    } catch (error) {\r\n      console.error('Error starting location tracking:', error);\r\n      \r\n      // Set state after a delay\r\n      trackingTimeoutRef.current = setTimeout(() => {\r\n        setIsTracking(false);\r\n        isTrackingRef.current = false;\r\n        trackingTimeoutRef.current = null;\r\n      }, 2000);\r\n      \r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Stop location tracking with debounce\r\n  const stopLocationTracking = () => {\r\n    // Prevent stopping if not tracking\r\n    if (!isTrackingRef.current) {\r\n      return;\r\n    }\r\n    \r\n    // Remove listeners first to prevent callbacks\r\n    locationService.removeAllListeners();\r\n    locationService.stopTracking();\r\n    \r\n    // Set state with a slight delay to prevent rapid toggling\r\n    if (trackingTimeoutRef.current) {\r\n      clearTimeout(trackingTimeoutRef.current);\r\n    }\r\n    \r\n    trackingTimeoutRef.current = setTimeout(() => {\r\n      setIsTracking(false);\r\n      isTrackingRef.current = false;\r\n      trackingTimeoutRef.current = null;\r\n    }, 500); // Half-second delay\r\n  };\r\n\r\n  return (\r\n    <LocationContext.Provider\r\n      value={{\r\n        myLocation,\r\n        connectedUsers,\r\n        isTracking,\r\n        trackingError,\r\n        wsConnected,\r\n        startLocationTracking,\r\n        stopLocationTracking\r\n      }}\r\n    >\r\n      {children}\r\n    </LocationContext.Provider>\r\n  );\r\n};\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}