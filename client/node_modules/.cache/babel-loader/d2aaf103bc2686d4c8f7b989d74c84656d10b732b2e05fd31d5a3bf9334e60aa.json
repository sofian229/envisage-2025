{"ast":null,"code":"var _jsxFileName = \"C:\\\\Programming\\\\Clubs\\\\CIS\\\\HackPrix\\\\drift-guard-1pm\\\\client\\\\src\\\\contexts\\\\LocationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useRef } from 'react';\nimport { useAuth } from './AuthContext';\nimport webSocketService from '../utils/websocket';\nimport locationService from '../utils/locationService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LocationContext = /*#__PURE__*/createContext();\nexport const useLocation = () => {\n  _s();\n  return useContext(LocationContext);\n};\n_s(useLocation, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const LocationProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [myLocation, setMyLocation] = useState(null);\n  const [connectedUsers, setConnectedUsers] = useState({});\n  const [isTracking, setIsTracking] = useState(false);\n  const [trackingError, setTrackingError] = useState(null);\n\n  // Add refs to track state changes and prevent rapid toggling\n  const trackingTimeoutRef = useRef(null);\n  const isTrackingRef = useRef(false);\n  const trackingAttemptsRef = useRef(0);\n  const MAX_TRACKING_ATTEMPTS = 3;\n\n  // Initialize WebSocket connection when user is authenticated\n  useEffect(() => {\n    if (!user) return;\n    const token = localStorage.getItem('userToken');\n    if (!token) return;\n\n    // Connect to WebSocket\n    webSocketService.connect(token);\n\n    // Add WebSocket message listener\n    const handleMessage = data => {\n      if (data.type === 'locationUpdate' && data.userId !== user.id) {\n        setConnectedUsers(prev => ({\n          ...prev,\n          [data.userId]: {\n            userId: data.userId,\n            userName: data.userName,\n            role: data.role,\n            coordinates: data.coordinates,\n            timestamp: data.timestamp\n          }\n        }));\n      }\n    };\n    webSocketService.addListener('message', handleMessage);\n\n    // Cleanup\n    return () => {\n      webSocketService.removeListener('message', handleMessage);\n      webSocketService.disconnect();\n\n      // Clear any pending timeouts\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n        trackingTimeoutRef.current = null;\n      }\n    };\n  }, [user]);\n\n  // Start location tracking with debounce and error handling\n  const startLocationTracking = () => {\n    // Prevent starting if already tracking or if we've had too many attempts\n    if (isTrackingRef.current) {\n      return true;\n    }\n    if (trackingAttemptsRef.current >= MAX_TRACKING_ATTEMPTS) {\n      setTrackingError('Too many tracking attempts. Please refresh the page and try again.');\n      return false;\n    }\n\n    // Increment tracking attempts\n    trackingAttemptsRef.current += 1;\n    if (!user) {\n      setTrackingError('User must be logged in to track location');\n      return false;\n    }\n    setTrackingError(null);\n\n    // Set tracking state to prevent multiple calls\n    isTrackingRef.current = true;\n    setIsTracking(true);\n\n    // Add location update listener\n    const handleLocationUpdate = coordinates => {\n      setMyLocation(coordinates);\n\n      // Reset tracking attempts on successful update\n      trackingAttemptsRef.current = 0;\n    };\n    const handleLocationError = error => {\n      console.error('Location tracking error:', error);\n      setTrackingError(error.message || 'Unknown location tracking error');\n\n      // Use timeout to prevent rapid toggling\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n      }\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000); // 2 second delay before allowing state change\n    };\n    locationService.addListener('update', handleLocationUpdate);\n    locationService.addListener('error', handleLocationError);\n\n    // Start tracking with a delay to prevent rapid toggling\n    try {\n      const success = locationService.startTracking();\n      if (!success) {\n        // If tracking fails, set state after a delay\n        trackingTimeoutRef.current = setTimeout(() => {\n          setIsTracking(false);\n          isTrackingRef.current = false;\n          trackingTimeoutRef.current = null;\n        }, 2000);\n      }\n      return success;\n    } catch (error) {\n      console.error('Error starting location tracking:', error);\n\n      // Set state after a delay\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000);\n      return false;\n    }\n  };\n\n  // Stop location tracking with debounce\n  const stopLocationTracking = () => {\n    // Prevent stopping if not tracking\n    if (!isTrackingRef.current) {\n      return;\n    }\n\n    // Remove listeners first to prevent callbacks\n    locationService.removeAllListeners();\n    locationService.stopTracking();\n\n    // Set state with a slight delay to prevent rapid toggling\n    if (trackingTimeoutRef.current) {\n      clearTimeout(trackingTimeoutRef.current);\n    }\n    trackingTimeoutRef.current = setTimeout(() => {\n      setIsTracking(false);\n      isTrackingRef.current = false;\n      trackingTimeoutRef.current = null;\n    }, 500); // Half-second delay\n  };\n  return /*#__PURE__*/_jsxDEV(LocationContext.Provider, {\n    value: {\n      myLocation,\n      connectedUsers,\n      isTracking,\n      trackingError,\n      startLocationTracking,\n      stopLocationTracking\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 169,\n    columnNumber: 5\n  }, this);\n};\n_s2(LocationProvider, \"xWO6ynpMefKbYfSv4l+WAHct5lg=\", false, function () {\n  return [useAuth];\n});\n_c = LocationProvider;\nvar _c;\n$RefreshReg$(_c, \"LocationProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useRef","useAuth","webSocketService","locationService","jsxDEV","_jsxDEV","LocationContext","useLocation","_s","LocationProvider","children","_s2","user","myLocation","setMyLocation","connectedUsers","setConnectedUsers","isTracking","setIsTracking","trackingError","setTrackingError","trackingTimeoutRef","isTrackingRef","trackingAttemptsRef","MAX_TRACKING_ATTEMPTS","token","localStorage","getItem","connect","handleMessage","data","type","userId","id","prev","userName","role","coordinates","timestamp","addListener","removeListener","disconnect","current","clearTimeout","startLocationTracking","handleLocationUpdate","handleLocationError","error","console","message","setTimeout","success","startTracking","stopLocationTracking","removeAllListeners","stopTracking","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Programming/Clubs/CIS/HackPrix/drift-guard-1pm/client/src/contexts/LocationContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useRef } from 'react';\nimport { useAuth } from './AuthContext';\nimport webSocketService from '../utils/websocket';\nimport locationService from '../utils/locationService';\n\nconst LocationContext = createContext();\n\nexport const useLocation = () => useContext(LocationContext);\n\nexport const LocationProvider = ({ children }) => {\n  const { user } = useAuth();\n  const [myLocation, setMyLocation] = useState(null);\n  const [connectedUsers, setConnectedUsers] = useState({});\n  const [isTracking, setIsTracking] = useState(false);\n  const [trackingError, setTrackingError] = useState(null);\n  \n  // Add refs to track state changes and prevent rapid toggling\n  const trackingTimeoutRef = useRef(null);\n  const isTrackingRef = useRef(false);\n  const trackingAttemptsRef = useRef(0);\n  const MAX_TRACKING_ATTEMPTS = 3;\n\n  // Initialize WebSocket connection when user is authenticated\n  useEffect(() => {\n    if (!user) return;\n\n    const token = localStorage.getItem('userToken');\n    if (!token) return;\n\n    // Connect to WebSocket\n    webSocketService.connect(token);\n\n    // Add WebSocket message listener\n    const handleMessage = (data) => {\n      if (data.type === 'locationUpdate' && data.userId !== user.id) {\n        setConnectedUsers(prev => ({\n          ...prev,\n          [data.userId]: {\n            userId: data.userId,\n            userName: data.userName,\n            role: data.role,\n            coordinates: data.coordinates,\n            timestamp: data.timestamp\n          }\n        }));\n      }\n    };\n\n    webSocketService.addListener('message', handleMessage);\n\n    // Cleanup\n    return () => {\n      webSocketService.removeListener('message', handleMessage);\n      webSocketService.disconnect();\n      \n      // Clear any pending timeouts\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n        trackingTimeoutRef.current = null;\n      }\n    };\n  }, [user]);\n\n  // Start location tracking with debounce and error handling\n  const startLocationTracking = () => {\n    // Prevent starting if already tracking or if we've had too many attempts\n    if (isTrackingRef.current) {\n      return true;\n    }\n    \n    if (trackingAttemptsRef.current >= MAX_TRACKING_ATTEMPTS) {\n      setTrackingError('Too many tracking attempts. Please refresh the page and try again.');\n      return false;\n    }\n    \n    // Increment tracking attempts\n    trackingAttemptsRef.current += 1;\n    \n    if (!user) {\n      setTrackingError('User must be logged in to track location');\n      return false;\n    }\n\n    setTrackingError(null);\n    \n    // Set tracking state to prevent multiple calls\n    isTrackingRef.current = true;\n    setIsTracking(true);\n\n    // Add location update listener\n    const handleLocationUpdate = (coordinates) => {\n      setMyLocation(coordinates);\n      \n      // Reset tracking attempts on successful update\n      trackingAttemptsRef.current = 0;\n    };\n\n    const handleLocationError = (error) => {\n      console.error('Location tracking error:', error);\n      setTrackingError(error.message || 'Unknown location tracking error');\n      \n      // Use timeout to prevent rapid toggling\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n      }\n      \n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000); // 2 second delay before allowing state change\n    };\n\n    locationService.addListener('update', handleLocationUpdate);\n    locationService.addListener('error', handleLocationError);\n\n    // Start tracking with a delay to prevent rapid toggling\n    try {\n      const success = locationService.startTracking();\n      \n      if (!success) {\n        // If tracking fails, set state after a delay\n        trackingTimeoutRef.current = setTimeout(() => {\n          setIsTracking(false);\n          isTrackingRef.current = false;\n          trackingTimeoutRef.current = null;\n        }, 2000);\n      }\n      \n      return success;\n    } catch (error) {\n      console.error('Error starting location tracking:', error);\n      \n      // Set state after a delay\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000);\n      \n      return false;\n    }\n  };\n\n  // Stop location tracking with debounce\n  const stopLocationTracking = () => {\n    // Prevent stopping if not tracking\n    if (!isTrackingRef.current) {\n      return;\n    }\n    \n    // Remove listeners first to prevent callbacks\n    locationService.removeAllListeners();\n    locationService.stopTracking();\n    \n    // Set state with a slight delay to prevent rapid toggling\n    if (trackingTimeoutRef.current) {\n      clearTimeout(trackingTimeoutRef.current);\n    }\n    \n    trackingTimeoutRef.current = setTimeout(() => {\n      setIsTracking(false);\n      isTrackingRef.current = false;\n      trackingTimeoutRef.current = null;\n    }, 500); // Half-second delay\n  };\n\n  return (\n    <LocationContext.Provider\n      value={{\n        myLocation,\n        connectedUsers,\n        isTracking,\n        trackingError,\n        startLocationTracking,\n        stopLocationTracking\n      }}\n    >\n      {children}\n    </LocationContext.Provider>\n  );\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}