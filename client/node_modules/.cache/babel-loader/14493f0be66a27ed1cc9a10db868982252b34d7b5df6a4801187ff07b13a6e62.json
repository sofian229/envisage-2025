{"ast":null,"code":"var _jsxFileName = \"C:\\\\Programming\\\\Clubs\\\\CIS\\\\HackPrix\\\\drift-guard-1pm\\\\client\\\\src\\\\contexts\\\\LocationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useRef } from 'react';\nimport { useAuth } from './AuthContext';\nimport webSocketService from '../utils/websocket';\nimport locationService from '../utils/locationService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LocationContext = /*#__PURE__*/createContext();\nexport const useLocation = () => {\n  _s();\n  return useContext(LocationContext);\n};\n_s(useLocation, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const LocationProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [myLocation, setMyLocation] = useState(null);\n  const [connectedUsers, setConnectedUsers] = useState({});\n  const [isTracking, setIsTracking] = useState(false);\n  const [trackingError, setTrackingError] = useState(null);\n  const [wsConnected, setWsConnected] = useState(false);\n\n  // Add refs to track state changes and prevent rapid toggling\n  const trackingTimeoutRef = useRef(null);\n  const isTrackingRef = useRef(false);\n  const trackingAttemptsRef = useRef(0);\n  const MAX_TRACKING_ATTEMPTS = 3;\n\n  // Initialize WebSocket connection when user is authenticated\n  useEffect(() => {\n    if (!user) return;\n    const token = localStorage.getItem('userToken');\n    if (!token) return;\n\n    // Connect to WebSocket\n    webSocketService.connect(token);\n\n    // Add WebSocket message listener\n    const handleMessage = data => {\n      if (data.type === 'locationUpdate' && data.userId !== user.id) {\n        setConnectedUsers(prev => ({\n          ...prev,\n          [data.userId]: {\n            userId: data.userId,\n            userName: data.userName,\n            role: data.role,\n            coordinates: data.coordinates,\n            timestamp: data.timestamp\n          }\n        }));\n      } else if (data.type === 'connected') {\n        setWsConnected(true);\n      }\n    };\n    const handleOpen = () => {\n      setWsConnected(true);\n    };\n    const handleClose = () => {\n      setWsConnected(false);\n    };\n    const handleError = () => {\n      setWsConnected(false);\n    };\n    webSocketService.addListener('message', handleMessage);\n    webSocketService.addListener('open', handleOpen);\n    webSocketService.addListener('close', handleClose);\n    webSocketService.addListener('error', handleError);\n\n    // Cleanup\n    return () => {\n      webSocketService.removeListener('message', handleMessage);\n      webSocketService.removeListener('open', handleOpen);\n      webSocketService.removeListener('close', handleClose);\n      webSocketService.removeListener('error', handleError);\n      webSocketService.disconnect();\n\n      // Clear any pending timeouts\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n        trackingTimeoutRef.current = null;\n      }\n    };\n  }, [user]);\n\n  // Start location tracking with debounce and error handling\n  const startLocationTracking = () => {\n    // Prevent starting if already tracking or if we've had too many attempts\n    if (isTrackingRef.current) {\n      return true;\n    }\n    if (trackingAttemptsRef.current >= MAX_TRACKING_ATTEMPTS) {\n      setTrackingError('Too many tracking attempts. Please refresh the page and try again.');\n      return false;\n    }\n\n    // Increment tracking attempts\n    trackingAttemptsRef.current += 1;\n    if (!user) {\n      setTrackingError('User must be logged in to track location');\n      return false;\n    }\n    setTrackingError(null);\n\n    // Set tracking state to prevent multiple calls\n    isTrackingRef.current = true;\n    setIsTracking(true);\n\n    // Add location update listener\n    const handleLocationUpdate = coordinates => {\n      setMyLocation(coordinates);\n\n      // Reset tracking attempts on successful update\n      trackingAttemptsRef.current = 0;\n    };\n    const handleLocationError = error => {\n      console.error('Location tracking error:', error);\n      setTrackingError(error.message || 'Unknown location tracking error');\n\n      // Use timeout to prevent rapid toggling\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n      }\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000); // 2 second delay before allowing state change\n    };\n    locationService.addListener('update', handleLocationUpdate);\n    locationService.addListener('error', handleLocationError);\n\n    // Start tracking with a delay to prevent rapid toggling\n    try {\n      const success = locationService.startTracking();\n      if (!success) {\n        // If tracking fails, set state after a delay\n        trackingTimeoutRef.current = setTimeout(() => {\n          setIsTracking(false);\n          isTrackingRef.current = false;\n          trackingTimeoutRef.current = null;\n        }, 2000);\n      }\n      return success;\n    } catch (error) {\n      console.error('Error starting location tracking:', error);\n\n      // Set state after a delay\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000);\n      return false;\n    }\n  };\n\n  // Stop location tracking with debounce\n  const stopLocationTracking = () => {\n    // Prevent stopping if not tracking\n    if (!isTrackingRef.current) {\n      return;\n    }\n\n    // Remove listeners first to prevent callbacks\n    locationService.removeAllListeners();\n    locationService.stopTracking();\n\n    // Set state with a slight delay to prevent rapid toggling\n    if (trackingTimeoutRef.current) {\n      clearTimeout(trackingTimeoutRef.current);\n    }\n    trackingTimeoutRef.current = setTimeout(() => {\n      setIsTracking(false);\n      isTrackingRef.current = false;\n      trackingTimeoutRef.current = null;\n    }, 500); // Half-second delay\n  };\n  return /*#__PURE__*/_jsxDEV(LocationContext.Provider, {\n    value: {\n      myLocation,\n      connectedUsers,\n      isTracking,\n      trackingError,\n      wsConnected,\n      startLocationTracking,\n      stopLocationTracking\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 190,\n    columnNumber: 5\n  }, this);\n};\n_s2(LocationProvider, \"D70RUUlfPdNxWMl0yz/ev4ec52k=\", false, function () {\n  return [useAuth];\n});\n_c = LocationProvider;\nvar _c;\n$RefreshReg$(_c, \"LocationProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useRef","useAuth","webSocketService","locationService","jsxDEV","_jsxDEV","LocationContext","useLocation","_s","LocationProvider","children","_s2","user","myLocation","setMyLocation","connectedUsers","setConnectedUsers","isTracking","setIsTracking","trackingError","setTrackingError","wsConnected","setWsConnected","trackingTimeoutRef","isTrackingRef","trackingAttemptsRef","MAX_TRACKING_ATTEMPTS","token","localStorage","getItem","connect","handleMessage","data","type","userId","id","prev","userName","role","coordinates","timestamp","handleOpen","handleClose","handleError","addListener","removeListener","disconnect","current","clearTimeout","startLocationTracking","handleLocationUpdate","handleLocationError","error","console","message","setTimeout","success","startTracking","stopLocationTracking","removeAllListeners","stopTracking","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Programming/Clubs/CIS/HackPrix/drift-guard-1pm/client/src/contexts/LocationContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useRef } from 'react';\nimport { useAuth } from './AuthContext';\nimport webSocketService from '../utils/websocket';\nimport locationService from '../utils/locationService';\n\nconst LocationContext = createContext();\n\nexport const useLocation = () => useContext(LocationContext);\n\nexport const LocationProvider = ({ children }) => {\n  const { user } = useAuth();\n  const [myLocation, setMyLocation] = useState(null);\n  const [connectedUsers, setConnectedUsers] = useState({});\n  const [isTracking, setIsTracking] = useState(false);\n  const [trackingError, setTrackingError] = useState(null);\n  const [wsConnected, setWsConnected] = useState(false);\n  \n  // Add refs to track state changes and prevent rapid toggling\n  const trackingTimeoutRef = useRef(null);\n  const isTrackingRef = useRef(false);\n  const trackingAttemptsRef = useRef(0);\n  const MAX_TRACKING_ATTEMPTS = 3;\n\n  // Initialize WebSocket connection when user is authenticated\n  useEffect(() => {\n    if (!user) return;\n\n    const token = localStorage.getItem('userToken');\n    if (!token) return;\n\n    // Connect to WebSocket\n    webSocketService.connect(token);\n\n    // Add WebSocket message listener\n    const handleMessage = (data) => {\n      if (data.type === 'locationUpdate' && data.userId !== user.id) {\n        setConnectedUsers(prev => ({\n          ...prev,\n          [data.userId]: {\n            userId: data.userId,\n            userName: data.userName,\n            role: data.role,\n            coordinates: data.coordinates,\n            timestamp: data.timestamp\n          }\n        }));\n      } else if (data.type === 'connected') {\n        setWsConnected(true);\n      }\n    };\n\n    const handleOpen = () => {\n      setWsConnected(true);\n    };\n\n    const handleClose = () => {\n      setWsConnected(false);\n    };\n\n    const handleError = () => {\n      setWsConnected(false);\n    };\n\n    webSocketService.addListener('message', handleMessage);\n    webSocketService.addListener('open', handleOpen);\n    webSocketService.addListener('close', handleClose);\n    webSocketService.addListener('error', handleError);\n\n    // Cleanup\n    return () => {\n      webSocketService.removeListener('message', handleMessage);\n      webSocketService.removeListener('open', handleOpen);\n      webSocketService.removeListener('close', handleClose);\n      webSocketService.removeListener('error', handleError);\n      webSocketService.disconnect();\n      \n      // Clear any pending timeouts\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n        trackingTimeoutRef.current = null;\n      }\n    };\n  }, [user]);\n\n  // Start location tracking with debounce and error handling\n  const startLocationTracking = () => {\n    // Prevent starting if already tracking or if we've had too many attempts\n    if (isTrackingRef.current) {\n      return true;\n    }\n    \n    if (trackingAttemptsRef.current >= MAX_TRACKING_ATTEMPTS) {\n      setTrackingError('Too many tracking attempts. Please refresh the page and try again.');\n      return false;\n    }\n    \n    // Increment tracking attempts\n    trackingAttemptsRef.current += 1;\n    \n    if (!user) {\n      setTrackingError('User must be logged in to track location');\n      return false;\n    }\n\n    setTrackingError(null);\n    \n    // Set tracking state to prevent multiple calls\n    isTrackingRef.current = true;\n    setIsTracking(true);\n\n    // Add location update listener\n    const handleLocationUpdate = (coordinates) => {\n      setMyLocation(coordinates);\n      \n      // Reset tracking attempts on successful update\n      trackingAttemptsRef.current = 0;\n    };\n\n    const handleLocationError = (error) => {\n      console.error('Location tracking error:', error);\n      setTrackingError(error.message || 'Unknown location tracking error');\n      \n      // Use timeout to prevent rapid toggling\n      if (trackingTimeoutRef.current) {\n        clearTimeout(trackingTimeoutRef.current);\n      }\n      \n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000); // 2 second delay before allowing state change\n    };\n\n    locationService.addListener('update', handleLocationUpdate);\n    locationService.addListener('error', handleLocationError);\n\n    // Start tracking with a delay to prevent rapid toggling\n    try {\n      const success = locationService.startTracking();\n      \n      if (!success) {\n        // If tracking fails, set state after a delay\n        trackingTimeoutRef.current = setTimeout(() => {\n          setIsTracking(false);\n          isTrackingRef.current = false;\n          trackingTimeoutRef.current = null;\n        }, 2000);\n      }\n      \n      return success;\n    } catch (error) {\n      console.error('Error starting location tracking:', error);\n      \n      // Set state after a delay\n      trackingTimeoutRef.current = setTimeout(() => {\n        setIsTracking(false);\n        isTrackingRef.current = false;\n        trackingTimeoutRef.current = null;\n      }, 2000);\n      \n      return false;\n    }\n  };\n\n  // Stop location tracking with debounce\n  const stopLocationTracking = () => {\n    // Prevent stopping if not tracking\n    if (!isTrackingRef.current) {\n      return;\n    }\n    \n    // Remove listeners first to prevent callbacks\n    locationService.removeAllListeners();\n    locationService.stopTracking();\n    \n    // Set state with a slight delay to prevent rapid toggling\n    if (trackingTimeoutRef.current) {\n      clearTimeout(trackingTimeoutRef.current);\n    }\n    \n    trackingTimeoutRef.current = setTimeout(() => {\n      setIsTracking(false);\n      isTrackingRef.current = false;\n      trackingTimeoutRef.current = null;\n    }, 500); // Half-second delay\n  };\n\n  return (\n    <LocationContext.Provider\n      value={{\n        myLocation,\n        connectedUsers,\n        isTracking,\n        trackingError,\n        wsConnected,\n        startLocationTracking,\n        stopLocationTracking\n      }}\n    >\n      {children}\n    </LocationContext.Provider>\n  );\n};\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}